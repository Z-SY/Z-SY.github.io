{
    "version": "https://jsonfeed.org/version/1",
    "title": "心無旁騖 斷而敢行",
    "subtitle": "君子如竹，當品性高潔；君心似水，當靜遠流深",
    "icon": "https://z-sy.github.io/images/favicon.ico",
    "description": "",
    "home_page_url": "https://Z-SY.github.io",
    "items": [
        {
            "id": "https://z-sy.github.io/2021/01/04/algorithm-2021-01-04-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%A8%81%E5%8A%9B/",
            "url": "https://z-sy.github.io/2021/01/04/algorithm-2021-01-04-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%A8%81%E5%8A%9B/",
            "title": "基本操作的威力",
            "date_published": "2021-01-04T12:29:38.000Z",
            "content_html": "<h1 id=\"0x00-开篇\"><a class=\"anchor\" href=\"#0x00-开篇\">#</a> 0x00 开篇</h1>\n<ul>\n<li><span class=\"kbd\">勉励语 - 去留无意，闲看庭前花开花落；宠辱不惊，漫随天外云卷云舒</span></li>\n</ul>\n<h1 id=\"0x01-问题-一次友好的对话\"><a class=\"anchor\" href=\"#0x01-问题-一次友好的对话\">#</a> 0x01 问题 - 一次友好的对话</h1>\n<ul>\n<li>输入 - n 元一维向量</li>\n<li>输出 - 向左旋转 i 个位置的 n 元一维向量</li>\n<li>约束 - 仅使用几十个额外字节的内存空间，在正比于 n 的时间内完成向量的旋转</li>\n</ul>\n<h1 id=\"0x02-问题分析\"><a class=\"anchor\" href=\"#0x02-问题分析\">#</a> 0x02 问题分析</h1>\n<ul>\n<li>假设 n=8，i=3，向量 abcdefgh 旋转为向量 defghabc。简单的代码使用一个 n 元的中间向量在 n 步内可完成该工作。</li>\n</ul>\n<h1 id=\"0x03-应用算法\"><a class=\"anchor\" href=\"#0x03-应用算法\">#</a> 0x03 应用算法</h1>\n<ol>\n<li>将向量 x 中的前 i 个元素复制到一个临时数组中，接着将余下的 n-i 个元素左移 i 个位置，然后再将前 i 个元素从临时数组中复制到 x 中余下的位置。<br />\n::: 性能分析<br />\n这种方法使用了 i 个额外的位置，如果 i 很大则产生了过大的存储空间的消耗<br />\n:::</li>\n</ol>\n<pre><code class=\"language-c++\">#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\n \nint main()\n&#123;\n    string s = &quot;abcdefghijklmn&quot;;\n    cout&lt;&lt; &quot;The origin is: &quot;&lt;&lt;s&lt;&lt; endl;\n    // 左移个数\n    int i;\n    cin&gt;&gt;i;\n    if(i&gt;s.size())\n    &#123;\n        i = i%s.size();\n    &#125;\n    // 将前i个元素临时保存\n    string tmp(s,0,i);\n    // 将剩余的左移i个位置\n    for(int j=i;j&lt;s.size();++j)\n    &#123;\n        s[j-i] = s[j];\n    &#125;\n    s = s.substr(0,s.size()-i) + tmp;\n    cout&lt;&lt; &quot;The result is: &quot;&lt;&lt;s&lt;&lt; endl;\n    return 0;\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>定义一个函数将 x 向左旋转一个位置（其时间正比于 n），然后调用该函数 i 次。<br />\n::: 性能分析<br />\n这种方法虽然空间复杂度为 O (1)，但产生了过多的运行时间消耗<br />\n:::</li>\n</ol>\n<pre><code class=\"language-c++\">#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\n \nvoid rotateOnce(string &amp;s)\n&#123;\n    char tmp = s[0];\n    int i;\n    for(i=1; i&lt;s.size(); ++i)\n    &#123;\n        s[i-1] = s[i];\n    &#125;\n    s[i-1] = tmp;\n&#125;\n \n \nint main()\n&#123;\n    string s = &quot;abcdefghijklmn&quot;;\n    cout &lt;&lt; &quot;The origin is: &quot; &lt;&lt; s &lt;&lt; endl;\n    // 左移个数\n    int i;\n    cin &gt;&gt; i;\n    if(i &gt; s.size())\n    &#123;\n        i = i%s.size();\n    &#125;\n    // 调用函数i次\n    while(i--)\n    &#123;\n        rotateOnce(s);\n    &#125;\n    cout &lt;&lt; &quot;The result is: &quot;&lt;&lt; s &lt;&lt; endl;\n    return 0;\n&#125;\n</code></pre>\n<ol start=\"3\">\n<li>移动 x [0] 到临时变量 t 中，然后移动 x [i] 到 x [0] 中，x [2i] 到 x [i]，依次类推，直到我们又回到 x [0] 的位置提取元素，此时改为从临时变量 t 中提取元素，然后结束该过程（当下标大于 n 时对 n 取模或者减去 n）。如果该过程没有移动全部的元素，就从 x [1] 开始再次进行移动，总共移动 i 和 n 的最大公约数次。<br />\n::: 性能分析<br />\n这种方法非常精巧，像书中所说的一样堪称巧妙的杂技表演。空间复杂度为 O (1)，时间复杂度为线性时间，满足问题的性能要求，但还不是最佳<br />\n:::</li>\n</ol>\n<pre><code class=\"language-c++\">#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\n \n// 欧几里德（辗转相除）算法求最大公约数\nint gcd(int i, int j)\n&#123;\n    while(1)\n    &#123;\n        if(i &gt; j)\n        &#123;\n            i = i%j;\n            if(i == 0)\n            &#123;\n                return j;\n            &#125;\n        &#125;\n        if(j &gt; i)\n        &#123;\n            j = j%i;\n            if(j == 0)\n            &#123;\n                return i;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n \nint main()\n&#123;\n    string s = &quot;abcdefghijklmn&quot;;\n    cout &lt;&lt; &quot;The origin is: &quot;&lt;&lt; s &lt;&lt; endl;\n    // 左移个数\n    int i;\n    cin &gt;&gt; i;\n    if(i &gt; s.size())\n    &#123;\n        i = i%s.size();\n    &#125;\n    // 移动\n    char tmp;\n    int times = gcd(s.size(), i);\n    for(int j=0; j&lt;times; ++j)\n    &#123;\n        tmp = s[j];\n        int pre = j; // 记录上一次的位置\n        while(1)\n        &#123;\n            int t = pre+i;\n            if(t &gt;= s.size())\n                t = t-s.size();\n            if(t == j) // 直到tmp原来的位置j为止\n                break;\n            s[pre] = s[t];\n            pre = t;\n        &#125;\n        s[pre] = tmp;\n    &#125;\n    cout &lt;&lt; &quot;The result is: &quot;&lt;&lt; s &lt;&lt; endl;\n    return 0;\n&#125;\n</code></pre>\n<ol start=\"4\">\n<li>旋转向量 x 实际上就是交换向量 ab 的两段，得到向量 ba，这里 a 代表 x 的前 i 个元素。假设 a 比 b 短。将 b 分割成 bl 和 br，使 br 的长度和 a 的长度一样。交换 a 和 br，将 ablbr 转换成 brbla。因为序列 a 已在它的最终位置了，所以我们可以集中精力交换 b 的两个部分了。由于这个新问题和原先的问题是一样的，所以我们以递归的方式进行解决。<br />\n::: 性能分析<br />\n这种方法可以得到优雅的程序，但是需要巧妙的代码，并且要进行一些思考才能看出它的效率足够高<br />\n:::</li>\n</ol>\n<pre><code class=\"language-c++\">//略\n</code></pre>\n<ol start=\"5\">\n<li>（最佳）将这个问题看做是把数组 ab 转换成 ba，同时假定我们拥有一个函数可以将数组中特定部分的元素逆序。从 ab 开始，首先对 a 求逆，得到 arb，然后对 b 求逆，得到 arbr。最后整体求逆，得到（arbr）r，也就是 ba。<br />\n::: 性能分析<br />\n求逆序的方法在时间和空间上都很高效，而且代码非常简短，很难出错<br />\n:::</li>\n</ol>\n<pre><code class=\"language-c++\">#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\n \nvoid reverse(string &amp;s, int begin, int end)\n&#123;\n    while(begin &lt; end)\n    &#123;\n        char tmp = s[begin];\n        s[begin] = s[end];\n        s[end] = tmp;\n        ++begin;\n        --end;\n    &#125;\n&#125;\n \nint main()\n&#123;\n    string s = &quot;abcdefghijklmn&quot;;\n    cout &lt;&lt; &quot;The origin is: &quot;&lt;&lt; s &lt;&lt; endl;\n     \n    int i;\n    cin &gt;&gt; i;\n    if(i &gt; s.size())\n    &#123;\n        i = i%s.size();\n    &#125;\n \n    reverse(s, 0, i-1);\n    reverse(s, i, s.size()-1);\n    reverse(s, 0, s.size()-1);\n \n    cout &lt;&lt; &quot;The result is: &quot;&lt;&lt; s &lt;&lt; endl;\n    return 0;\n&#125;\n</code></pre>\n<h1 id=\"0x04-补充链接\"><a class=\"anchor\" href=\"#0x04-补充链接\">#</a> 0x04 补充链接</h1>\n<ul>\n<li>本文主要摘选自<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc29uZ2xlZS9wLzU3MzgxNDYuaHRtbA==\">神奕</span></li>\n</ul>\n",
            "tags": [
                "算法",
                "编程珠玑"
            ]
        },
        {
            "id": "https://z-sy.github.io/2021/01/03/penetration-test-2021-01-03-BurpSuite/",
            "url": "https://z-sy.github.io/2021/01/03/penetration-test-2021-01-03-BurpSuite/",
            "title": "BurpSuite",
            "date_published": "2021-01-03T09:36:26.000Z",
            "content_html": "<h1 id=\"0x00-开篇\"><a class=\"anchor\" href=\"#0x00-开篇\">#</a> 0x00 开篇</h1>\n<ul>\n<li><span class=\"kbd\">勉励语 - 书山有路勤为径，学海无涯苦作舟</span></li>\n</ul>\n<h1 id=\"0x01-介绍\"><a class=\"anchor\" href=\"#0x01-介绍\">#</a> 0x01 介绍</h1>\n<p>BurpSuite 是进行 Web 应用安全测试集成平台。它将各种安全工具无缝地融合在一起，以支持整个测试过程中，从最初的映射和应用程序的攻击面分析，到发现和利用安全漏洞。其模块几乎包含整个安全测试过程，从最初对目标程序的信息采集，到漏洞扫描及其利用，多模块间高融合的配合，使得安全测试的过程更加高效。</p>\n<h1 id=\"0x02-主要模块\"><a class=\"anchor\" href=\"#0x02-主要模块\">#</a> 0x02 主要模块</h1>\n<ol>\n<li>Dashboard</li>\n<li>Proxy</li>\n<li>Intruder</li>\n<li>Repeater</li>\n<li>Decoder</li>\n</ol>\n<h1 id=\"0x03-模块简介\"><a class=\"anchor\" href=\"#0x03-模块简介\">#</a> 0x03 模块简介</h1>\n<ol>\n<li><span class=\"kbd\">Proxy</span> - 代理模块作为 BurpSuite 的核心功能，拦截 HTTP/S 的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许拦截，查看，修改在两个方向上的原始数据流。\n<ul>\n<li><span class=\"kbd\">intercept 选项</span> - 用于显示修改 HTTP 请求及响应内容，并可以将拦截的 HTTP 请求快速发送至其他模块处理。\n<ul>\n<li><span class=\"kbd\">Forward</span> - 用于发送数据。当把所需要的 HTTP 请求编辑编辑完成后，手动发送数据。</li>\n<li><span class=\"kbd\">Drop</span> - 将该请求包丢弃。</li>\n<li><span class=\"kbd\">Intercept is off/on</span> - 拦截开关。当处于 off 状态下时，BurpSuite 会自动转发所拦截的所有请求；当处于 on 状态下时，BurpSuite 会将所有拦截所有符合规则的请求并将它显示出来等待编辑或其他操作。</li>\n<li><span class=\"kbd\">Action</span> - 功能菜单，与右键菜单内容相同，在这可以将请求包发送到其他的模块或者对数据包进行其他的操作。</li>\n</ul>\n</li>\n<li><span class=\"kbd\">http history 选项</span> - 这里将记录经过代理服务器访问的所有请求，即使当 Intercept is off 时也会记录。记录包括：#(请求索引号)、Host (主机)、Method (请求方式)、URL (请求地址)、Params (参数)、Edited (编辑)、Status (状态)、Length (响应字节长度)、MIME type (响应的 MLME 类型)、Extension (地址文件扩展名)、Title (页面标题)、Comment (注释)、SSL、IP (目标 IP 地址)、Cookies、Time (发出请求时间)、Listener port (监听端口)。</li>\n<li><span class=\"kbd\">WebSockets history 选项</span> - 用于记录 WebSockets 的数据包，是 HTML5 中最强大的通信功能，定义了一个全双工的通信信道，只需 Web 上的一个 Socket 即可进行通信，能减少不必要的网络流量并降低网络延迟。</li>\n<li><span class=\"kbd\">Options 选项</span> - 主要用于设置代理监听、请求和响应，拦截反应，匹配和替换，ssl 等。</li>\n</ul>\n</li>\n</ol>\n<div class=\"note info\">\n<p>在 BurpSuite 任何请求处，右键菜单选择 “Send to intruder” 选项，将自动发送到此模块下并自动相关内容。</p>\n</div>\n<ol start=\"2\">\n<li><span class=\"kbd\">Intruder</span> - 用于自动对 Web 应用程序自定义的攻击。它可以用来自动执行您的测试过程中可能出现的所有类型的任务。例如目录爆破，注入，密码爆破等。\n<ul>\n<li><span class=\"kbd\">Target 选项</span> - 用于配置目标服务器进行攻击的详细信息。\n<ul>\n<li><span class=\"kbd\">Host</span> - 这是目标服务器的 IP 地址或主机名。</li>\n<li><span class=\"kbd\">Port</span> - 这是目标服务的端口号。</li>\n<li><span class=\"kbd\">Use HTTPS</span> - 这指定的 SSL 是否应该被使用.</li>\n</ul>\n</li>\n<li><span class=\"kbd\">Positions 选项</span> - 设置 Payloads 的插入点以及攻击类型（攻击模式）。</li>\n<li><span class=\"kbd\">Payloads 选项</span> - 设置 payload，配置字典。</li>\n<li><span class=\"kbd\">Opetions 选项</span> - 此选项卡包含了 request headers，request engine，attack results ，grep match，grep_extrack，grep payloads 和 redirections。可以发动攻击之前，在主要 Intruder 的 UI 上编辑这些选项，大部分设置也可以在攻击时对已在运行的窗口进行修改。</li>\n</ul>\n</li>\n<li><span class=\"kbd\">Repeater</span> - 用于手动操作和发送个别 HTTP 请求，并分析应用程序的响应一个简单的工具。可以发送一个内部请求从 Burp 任何地方到 Repeater，修改请求并且发送。</li>\n<li><span class=\"kbd\">Decoder</span> - 将原始数据转换成各种编码和哈希表的简单工具。它能够智能地识别多种编码格式采用启发式技术。</li>\n</ol>\n<h1 id=\"0x04-补充链接\"><a class=\"anchor\" href=\"#0x04-补充链接\">#</a> 0x04 补充链接</h1>\n<ul>\n<li>本文主要摘选自<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vanNqbGl5YW5nL3AvMTA4NTMzMDcuaHRtbA==\"> BurpSuite pro v2.0 使用入门教程</span></li>\n</ul>\n",
            "tags": [
                "渗透测试",
                "BurpSuit"
            ]
        },
        {
            "id": "https://z-sy.github.io/2021/01/03/penetration-test-2021-01-03-penetration-test-introduce/",
            "url": "https://z-sy.github.io/2021/01/03/penetration-test-2021-01-03-penetration-test-introduce/",
            "title": "模块介绍",
            "date_published": "2021-01-03T09:36:25.000Z",
            "content_html": "<h1 id=\"0x00-开篇\"><a class=\"anchor\" href=\"#0x00-开篇\">#</a> 0x00 开篇</h1>\n<p>本模块主要分享总结渗透测试的相关知识</p>\n",
            "tags": [
                "渗透测试"
            ]
        },
        {
            "id": "https://z-sy.github.io/2021/01/02/algorithm-2021-01-02-%E4%B8%80%E6%AC%A1%E5%8F%8B%E5%A5%BD%E7%9A%84%E5%AF%B9%E8%AF%9D/",
            "url": "https://z-sy.github.io/2021/01/02/algorithm-2021-01-02-%E4%B8%80%E6%AC%A1%E5%8F%8B%E5%A5%BD%E7%9A%84%E5%AF%B9%E8%AF%9D/",
            "title": "一次友好的对话",
            "date_published": "2021-01-02T00:40:30.000Z",
            "content_html": "<h1 id=\"0x00-开篇\"><a class=\"anchor\" href=\"#0x00-开篇\">#</a> 0x00 开篇</h1>\n<ul>\n<li><span class=\"kbd\">勉励语 - 非淡泊无以明志，非宁静无以致远</span></li>\n</ul>\n<h1 id=\"0x01-问题-一次友好的对话\"><a class=\"anchor\" href=\"#0x01-问题-一次友好的对话\">#</a> 0x01 问题 - 一次友好的对话</h1>\n<ul>\n<li>输入 - 一个最多包含 n 个正整数的文件，每个数都小于 n，其中 n=10^7。如果在输入文件中有任何整数重复出现就是致命错误。没有其他数据与该整数相关联。</li>\n<li>输出 - 按升序排列的输入整数的列表</li>\n<li>约束 - 最多大约有 1MB 的内存空间可用，有充足的磁盘存储空间可用。运行时间最多几分钟，运行时间 10S 就不需要进一步优化了。</li>\n</ul>\n<h1 id=\"0x02-问题分析\"><a class=\"anchor\" href=\"#0x02-问题分析\">#</a> 0x02 问题分析</h1>\n<ul>\n<li>常见方式一般的以基于磁盘的<span class=\"kbd\">归并排序</span>为起点，但需对其进行调整，由于是对整数进行排序，可将原来两百行的程序减少为十几行，且一般归并排序要用到中间文件，程序将运行的更快，但是完成程序可能仍然需要几天时间。</li>\n<li>另一种解决方案利用该问题的特殊性。如果每个号码都使用 7 字节来存储，那么在可用的 1MB 存储空间大约可存 143000 个号码。如果每个号码都使用 32 位整数来表示的话，在 1MB 的存储空间里就可以存储 250000 个号码。因此，可重复遍历输入文件 40 趟来完成排序。第一趟 - 0 至 249999；第二趟 - 250000 至 499999 依此类推。对于内存中的排序来讲<span class=\"kbd\">快速排序</span>相当高效，且该程序拥有所希望的特性 - 不必考虑使用中间磁盘文件，但为此付出的代价是读取输入文件 40 次。</li>\n<li>综上两方优点 - 我们想要的读输入文件一次，且不使用中间文件。最终，问题归结为能否能够用大约 800 万个可用位来表示最多 1000 万个互异的整数。</li>\n</ul>\n<h1 id=\"0x03-应用算法\"><a class=\"anchor\" href=\"#0x03-应用算法\">#</a> 0x03 应用算法</h1>\n<ul>\n<li>位图算法。BitMap 算法的核心思想是用 bit 数组来记录 0-1 两种状态，然后再将具体数据映射到这个比特数组的具体位置，这个比特位设置成 0 表示数据不存在，设置成 1 表示数据存在。</li>\n<li>BitMap 算在在大量数据查询、去重等应用场景中使用的比较多，这个算法具有比较高的空间利用率。</li>\n</ul>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/* 伪代码 */</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">/* phase 1: initialize set to empty */</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">for</span> i <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>n<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  bit<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">/* phase 2: insert present elements into the set */</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">for</span> each i in the input file</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  bit<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">/* phase 3: write sorted output */</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">for</span> i <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>n<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token keyword\">if</span> bit<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    write i on the output file</pre></td></tr></table></figure>",
            "tags": [
                "算法",
                "编程珠玑"
            ]
        },
        {
            "id": "https://z-sy.github.io/2020/12/30/binary-2020-12-30-0day%E5%AE%89%E5%85%A8%E6%B8%A9%E4%B9%A0-03/",
            "url": "https://z-sy.github.io/2020/12/30/binary-2020-12-30-0day%E5%AE%89%E5%85%A8%E6%B8%A9%E4%B9%A0-03/",
            "title": "0day安全温习-03",
            "date_published": "2020-12-30T15:32:35.000Z",
            "content_html": "<h1 id=\"0x00-开篇\"><a class=\"anchor\" href=\"#0x00-开篇\">#</a> 0x00 开篇</h1>\n<ul>\n<li><span class=\"kbd\">勉励语 - 立志言为本，修身行乃先</span></li>\n</ul>\n<h1 id=\"0x01-逆向常用工具\"><a class=\"anchor\" href=\"#0x01-逆向常用工具\">#</a> 0x01 逆向常用工具</h1>\n<div class=\"note info\">\n<p>包括但不限于</p>\n</div>\n<ul>\n<li>动态分析工具\n<ul>\n<li>OllyDbg</li>\n</ul>\n</li>\n<li>静态分析工具\n<ul>\n<li>IDA Pro</li>\n</ul>\n</li>\n<li>二进制编辑器\n<ul>\n<li>UltraEdit</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"0x02-栈溢出原理与实践\"><a class=\"anchor\" href=\"#0x02-栈溢出原理与实践\">#</a> 0x02 栈溢出原理与实践</h1>\n<ul>\n<li>何为<span class=\"kbd\">栈溢出</span>\n<ul>\n<li>简单来说，缓冲区溢出就是在大缓冲区中的数据向小缓冲区复制的过程中，由于没有注意小缓冲区的边界，“撑爆” 了较小的缓冲区，从而冲掉了和小缓冲区相邻内存区域的其它数据而引起的内存问题。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"0x03-两个寄存器esp和ebp\"><a class=\"anchor\" href=\"#0x03-两个寄存器esp和ebp\">#</a> 0x03 两个寄存器 ESP 和 EBP</h1>\n<pre><code>* ESP-栈指针寄存器(extended stack po inter)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。\n* EBP-基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。\n</code></pre>\n<h1 id=\"0x04-函数调用过程\"><a class=\"anchor\" href=\"#0x04-函数调用过程\">#</a> 0x04 函数调用过程</h1>\n<pre><code>* 在形成函数栈帧一般要经历如下几个步骤：push操作进行参数入栈---&gt;call调用进行下一条返回地址的入栈操作并跳入调用函数的代码区---&gt;进入函数代码区后，一个push ebp记录当前栈帧，一个mov ebp，esp设置新栈帧的底部，一个sud esp，xxx抬高新栈帧的顶部，留出局部变量的空间。至此一个新栈帧形成。同理，函数返回步骤如下：保存返回值，通常放在EAX寄存器中---&gt;弹出当前栈帧，恢复上一个栈帧。具体操作-首先根据堆栈平衡，给ESP加上栈帧的大小，降低栈顶，回收当前栈帧空间，其次将当前栈帧底部保存的前栈帧EBP数值弹入EBP寄存器，恢复出上一个栈帧的栈帧底部，将保存的call调用的下一条指令地址弹给EIP寄存器。完成了一个新栈帧的生命周期，创建和释放。\n</code></pre>\n<div class=\"note info\">\n<p>进行缓冲出溢出实验注意事项 - 函数的调用约定和相关指令。一般，参数入栈顺序从右至左 - C、Syscall、Stdcall，其中 C 的恢复栈平衡位置在母函数，剩下的两个都在子函数。参数入栈顺序从左至右 - Basic、Fortran、Pascal，其恢复栈平衡的位置都在子函数中进行。在进行淹没溢出操作时候要注意！</p>\n</div>\n",
            "tags": [
                "二进制",
                "0day安全"
            ]
        },
        {
            "id": "https://z-sy.github.io/2020/12/28/binary-2020-12-28-0day%E5%AE%89%E5%85%A8%E6%B8%A9%E4%B9%A0-02/",
            "url": "https://z-sy.github.io/2020/12/28/binary-2020-12-28-0day%E5%AE%89%E5%85%A8%E6%B8%A9%E4%B9%A0-02/",
            "title": "0day安全温习-02",
            "date_published": "2020-12-28T15:43:28.000Z",
            "content_html": "<h1 id=\"0x00-开篇\"><a class=\"anchor\" href=\"#0x00-开篇\">#</a> 0x00 开篇</h1>\n<ul>\n<li><span class=\"kbd\">勉励语 - 风之积也不厚，则其负大翼也无力</span></li>\n</ul>\n<h1 id=\"0x01-基础\"><a class=\"anchor\" href=\"#0x01-基础\">#</a> 0x01 基础</h1>\n<ol>\n<li>PE 文件格式\n<ul>\n<li>PE 全称 - Portable Executable，是 Win32 平台下可执行文件遵守的数据格式。常见的可执行文件（如 “<em>.exe” 文件和 “</em>.dll” 文件）都是典型的 PE 文件。</li>\n</ul>\n</li>\n<li>PE 文件格式的数据节（section）\n<ul>\n<li>.text - 由编译器产生，存放着二进制的机器代码，也是我们反汇编和调试的对象</li>\n<li>.data - 初始化的数据块，如宏定义、全局变量、静态变量等</li>\n<li>.idata - 可执行文件所使用的动态链接库等外来函数与文件的信息</li>\n<li>.rsrc - 存放程序的资源，如图标、菜单等</li>\n</ul>\n<div class=\"note info\">\n<p>正常编译出的标准 PE 文件，其节信息往往是大致相同的。但这些 section 的名字只是为了方便人的记忆与使用，使用 Microsoft Visual C++ 中的编译指示符 #pragma dat a_seg () 可以把代码中的任意部分编译到 PE 的任意节中，节名也可以自己定义。如果可执行文件经过了 “加壳” 处理，PE 的节信息就会变得非常 “古怪”。在 Crack 和反病毒分析中需要经常处理这类古怪的 PE 文件</p>\n</div>\n</li>\n<li>PE 与虚拟内存之间的映射\n<ul>\n<li>何为<span class=\"kbd\">文件偏移地址</span>\n<ul>\n<li>数据在 PE 文件中的地址叫文件偏移地址，个人认为叫做文件地址更加准确。这是文件在磁盘上存放时相对于文件开头的偏移。</li>\n</ul>\n</li>\n<li>何为<span class=\"kbd\">装载基址 - Image Base</span>\n<ul>\n<li>PE 装入内存时的基地址。默认情况下，EXE 文件在内存中的基地址是 0x00400000，DLL 文件是 0x10000000。这些位置可以通过修改编译选项更改。</li>\n</ul>\n</li>\n<li>何为<span class=\"kbd\">虚拟内存地址 - Virtual Address，VA）</span>\n<ul>\n<li>PE 文件中的指令被装入内存后的地址。</li>\n</ul>\n</li>\n<li>何为<span class=\"kbd\">相对虚拟地址（Relative Virtual Address，RVA）</span>\n<ul>\n<li>相对虚拟地址是内存地址相对于映射基址的偏移量。</li>\n</ul>\n</li>\n</ul>\n<div class=\"note info\">\n<p>VA= Image Base+ RVA</p>\n</div>\n</li>\n<li>节偏移\n<ul>\n<li>产生原因 - 文件数据的存放单位与内存数据存放单位不同，文件 - 0x200；内存 - 0x1000h，对于两者不足单位的数据都会用 0x00 进行填充补全</li>\n<li>换算公式\n<ul>\n<li>文件偏移地址 = 虚拟内存地址（VA）−装载基址（Image Base）−节偏移<br />\n = RVA - 节偏移</li>\n</ul>\n</li>\n</ul>\n<div class=\"note info\">\n<p>在进行转换时，还有判断要转换的地址位于那个节内，然后减去相应的节偏移</p>\n</div>\n<ul>\n<li>工具推荐 -<span class=\"kbd\">LordPE</span></li>\n</ul>\n</li>\n</ol>\n",
            "tags": [
                "二进制",
                "0day安全"
            ]
        },
        {
            "id": "https://z-sy.github.io/2020/12/27/binary-2020-12-27-0day%E5%AE%89%E5%85%A8%E6%B8%A9%E4%B9%A0-01/",
            "url": "https://z-sy.github.io/2020/12/27/binary-2020-12-27-0day%E5%AE%89%E5%85%A8%E6%B8%A9%E4%B9%A0-01/",
            "title": "0day安全温习-01",
            "date_published": "2020-12-27T15:17:07.000Z",
            "content_html": "<h1 id=\"0x00-开篇\"><a class=\"anchor\" href=\"#0x00-开篇\">#</a> 0x00 开篇</h1>\n<ul>\n<li><span class=\"kbd\">勉励语 - 精勤求学，敦笃励志</span></li>\n</ul>\n<h1 id=\"0x01-基础知识\"><a class=\"anchor\" href=\"#0x01-基础知识\">#</a> 0x01 基础知识</h1>\n<ol>\n<li>漏洞挖掘\n<ul>\n<li>安全性漏洞往往不会对软件本身功能造成很大影响，因此很难被 QA 工程师的功能性测试发现，对于进行 “正常操作” 的普通用户来说，更难体会到软件中的这类逻辑瑕疵。</li>\n<li>从技术角度讲，所谓的漏洞挖掘更像是高级的 QA，一群精通二进制、汇编语言和操作系统底层知识的大手子没日没夜、精力旺盛的测试产品，寻找产品中的漏洞，敏锐的捕捉到程序中那些微笑细微的错误。大型的软件企业也会雇用一些安全专家来测试自己产品中的漏洞，这种测试工作可称 - Penetration test（攻击测试）；这些测试团队则被称做 Tiger team 或者 Ethic hacker。</li>\n<li>工程界 - 普遍采用的方式是 Fuzz，实际是一种灰盒测试；学术界 - 侧重教导，一般采用静态分析。</li>\n</ul>\n</li>\n<li>漏洞分析\n<ul>\n<li>分析漏洞时，如果能搜索到 POC 代码，就能重现漏洞现场；如果不能获得 POC，比较通用的方法是采用补丁比较器，比较 Patch 前后的可执行程序修改了哪些地方，然后再重点分析。</li>\n</ul>\n</li>\n<li>漏洞利用\n<ul>\n<li>针对发现的漏洞，可部署相应的攻击代码测试代码，进行提权等操作。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"0x02-常用短语\"><a class=\"anchor\" href=\"#0x02-常用短语\">#</a> 0x02 常用短语</h1>\n<ol>\n<li>何为<span class=\"kbd\"> 0DAY</span> - 零日漏洞\n<ul>\n<li>未被公布，未被修复的漏洞。依次类推补丁刚刚发布的一段时间内，并非所有用户都能及时修复，故这种新公布的漏洞也有一定利用价值。有时把攻击这种刚刚被 patch 过的漏洞称为 1 day 攻击。（patch 发布后 1 天，叫做 1 day，5 天叫做 5 day，未发 patch 统称 0 day）</li>\n</ul>\n</li>\n<li>何为<span class=\"kbd\"> CVE</span>-<span class=\"exturl\" data-url=\"aHR0cDovL2N2ZS5taXRyZS5vcmcv\"> http://cve.mitre.org/</span>\n<ul>\n<li>英文全称是 “Common Vulnerabilities &amp; Exposures” 通用漏洞披露。CVE 就好像是一个字典表，为广泛认同的信息安全漏洞或者已经暴露出来的弱点给出一个公共的名称。</li>\n</ul>\n</li>\n<li>何为<span class=\"kbd\"> POC</span>\n<ul>\n<li>全称 'Proof of Concept'，中文概念验证，常指一段漏洞证明的代码。</li>\n</ul>\n</li>\n<li>何为<span class=\"kbd\"> EXP</span>\n<ul>\n<li>全称 'Exploit'，中文 ' 利用 '，指利用系统漏洞进行攻击的动作。</li>\n</ul>\n</li>\n<li>何为<span class=\"kbd\"> PayLoad</span>\n<ul>\n<li>中文 ' 有效载荷 '，指成功 exploit 之后真正在目标系统执行的代码或指令。</li>\n</ul>\n</li>\n<li>何为<span class=\"kbd\"> ShellCode</span>\n<ul>\n<li>简单翻译 'Shell 代码 '，是 Payload 的一种，由于其建立正向 / 反向 shell 而得名。</li>\n</ul>\n</li>\n</ol>\n",
            "tags": [
                "二进制",
                "0day安全"
            ]
        },
        {
            "id": "https://z-sy.github.io/2020/12/26/front-end-2020-12-26-front-introduce/",
            "url": "https://z-sy.github.io/2020/12/26/front-end-2020-12-26-front-introduce/",
            "title": "模块介绍",
            "date_published": "2020-12-26T10:18:22.000Z",
            "content_html": "<h1 id=\"0x00-开篇\"><a class=\"anchor\" href=\"#0x00-开篇\">#</a> 0x00 开篇</h1>\n<p>本模块主要梳理总结学习的前端相关知识</p>\n",
            "tags": [
                "前端"
            ]
        },
        {
            "id": "https://z-sy.github.io/2020/12/26/binary-2020-12-26-binary-introduce/",
            "url": "https://z-sy.github.io/2020/12/26/binary-2020-12-26-binary-introduce/",
            "title": "模块介绍",
            "date_published": "2020-12-26T10:18:21.000Z",
            "content_html": "<h1 id=\"0x00-开篇\"><a class=\"anchor\" href=\"#0x00-开篇\">#</a> 0x00 开篇</h1>\n<p>本模块主要梳理总结二进制知识体系，较为繁杂</p>\n",
            "tags": [
                "二进制"
            ]
        },
        {
            "id": "https://z-sy.github.io/2020/12/26/back-end-2020-12-26-back-introduce/",
            "url": "https://z-sy.github.io/2020/12/26/back-end-2020-12-26-back-introduce/",
            "title": "模块介绍",
            "date_published": "2020-12-26T10:18:20.000Z",
            "content_html": "<h1 id=\"0x00-开篇\"><a class=\"anchor\" href=\"#0x00-开篇\">#</a> 0x00 开篇</h1>\n<p>本模块主要梳理总结学习的后端相关知识</p>\n",
            "tags": [
                "后端"
            ]
        },
        {
            "id": "https://z-sy.github.io/2020/12/26/algorithm-2020-12-26-algorithm-introduce/",
            "url": "https://z-sy.github.io/2020/12/26/algorithm-2020-12-26-algorithm-introduce/",
            "title": "模块介绍",
            "date_published": "2020-12-26T10:18:19.000Z",
            "content_html": "<h1 id=\"0x00-开篇\"><a class=\"anchor\" href=\"#0x00-开篇\">#</a> 0x00 开篇</h1>\n<p>本模块主要梳理总结算法相关内容</p>\n",
            "tags": [
                "算法"
            ]
        },
        {
            "id": "https://z-sy.github.io/2020/12/26/FirstBlog/",
            "url": "https://z-sy.github.io/2020/12/26/FirstBlog/",
            "title": "关于本博客",
            "date_published": "2020-12-26T10:18:18.000Z",
            "content_html": "<h1 id=\"0x00-致谢\"><a class=\"anchor\" href=\"#0x00-致谢\">#</a> 0x00 致谢</h1>\n<ul>\n<li>首先，先感谢一下<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWU=\"> amehime</span> 大佬的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaG9rYS5sb3N0eXUubWUv\"> shoka 主题</span>吧，无意间了解到 hexo，后来点进了官网主题页面，访问了大佬的界面，一下子就被主题配色和音乐吸引住了，不能自拔❤️❤️❤️, 这满满的二次元调调，用美不胜收形容都不为过。推荐大家也去欣赏一下！</li>\n</ul>\n<h1 id=\"0x01-开篇\"><a class=\"anchor\" href=\"#0x01-开篇\">#</a> 0x01 开篇</h1>\n<ul>\n<li>嗯。。。也不算是第一篇博文吧。但是距离之前写的博文已经很久远了，且这回是第一次接触 hexo 来书写博客，所以一切都从头算好了！哈哈哈哈</li>\n</ul>\n<h1 id=\"0x02-关于捡回书写博客习惯的原因\"><a class=\"anchor\" href=\"#0x02-关于捡回书写博客习惯的原因\">#</a> 0x02 关于捡回书写博客习惯的原因</h1>\n<div class=\"note warning\">\n<p>警告：前方回忆杀预警💥💥💥</p>\n</div>\n<ul>\n<li>大学的时候，时间很多。对于计算机的兴趣非常大，每日除了课堂学的，回寝后自己也会瞎折腾好多东西，本地机子也好，VPS 也罢，都尝试了很多东西，但是说实话，很失败啊，随着时间的流逝，真正留下来的东西很少，无非是自己再听到这些东西的时候，脑子里有了个印象 -“啊，这个东西啊。我搞过；哎，也就那样，维护起来也怪累的”。</li>\n<li>搭过传奇的服务器，脚本里魔改了很多东西，过分到什么程度呢，一刀 999999 在我这都算是垃圾武器打出的暴击，哈哈哈哈哈。身为管理员，更是利用上帝特权各种给自己开后门😎（PS；学生党，没钱推广，而且只是本地起服务瞎折腾试试，所以别说我私服违规啥的🤣）；</li>\n<li>维护过 discuzz 论坛，论坛一般更新一些每月新番动漫，这个是租的 VPS，最便宜的打折搞活动那种🤧，速度是真的垃圾，偶尔高峰时段经常断联，而且访问速度感人。说实话，一个人的精力很有限，刚开始每天都会更新，打一些安全补丁啥的，但是越来越懒（可能也是访问量没啥起色吧，再加上便宜 VPS，也不咋心疼），后面估计是太久没更新，网站都让人脱库了，索性直接删了，服务器只当个跳板（看看外面，保持知识更新）用，用来看看油管，收集下载一些好玩的工具站啥的</li>\n<li>搭过 WordPress，这就是我最开始用的 CMS，那个时候是刚刚毕业工作吧，我一个北方汉子来到了广东这个陌生的城市，周末日常颓废时（这里说一下，陌生城市，人生地不熟，整个人的状态很容易变得很奇怪，我有段时间感觉经常一个人翻着知识站突然开始对着电脑神游发呆，不知道是刚毕业的迷茫还是一个人太久了，经常就开始神游太虚了，哈哈哈哈哈哈）就想，不如把工作生活中好多自己觉得好玩有趣的东西记录一下。这里说一下，Wordpress 确实对新手很友好，几乎全程是傻瓜式建站，基本不用做什么特别操作。倒是我自己，配置 LAMP 环境的时候，全部都从头自己搞了一遍，哇，第一次的时候是真滴酸爽，用了好长时间才跑起了服务，搭的时候就在想为啥没人写个 bash 脚本啥的呢，执行一次就完事得了。后来我才知道有宝塔这种神器（哭唧唧😱）一键配置脚本，当然，从头搞也不是没有好处，毕竟你自己对整个的流程就有了个大体的认识了。后面由于工作经常出差加懒癌晚期，遂又一次不了了之了</li>\n<li>视频解析站，这个没啥东西。接口都是网上搜的，我只是做了个整合，给我这种经济严重紧张的群体提供个方便罢了，后来发现自己搜的好多接口都不太稳定，而且有的接口各种广告，很影响心情，都不如直接度娘搜来的舒服，所以</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">cd</span> /var/www/html</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">rm</span> -rf ./Vipparse</pre></td></tr></table></figure><p>一气呵成，丝毫不犹豫，哈哈哈哈哈哈哈</p>\n<ul>\n<li>后来工作一年基本也不怎么折腾这些东西了，基本就是看到哪个东西自己感觉好玩就搞一段时间，玩腻了就直接弃坑转下一个战场。现在对于熟悉什么语言啥的也没啥感觉了，基本就是哪个方便需要哪个就上哪个，语法忘记了就直接看书上网搜一下。当然，C 和 C++ 还是相对来说偏爱的，毕竟毕业的第一份工作是嵌入式的工作，很喜欢接近底层的东西（写到这下意识的摸了下头发，还好，看来我还是很菜不够强，目前不用担心🤣）。仔细想想从大学到工作，破解过外挂，写过 app，写过修改器，破解过水卡，调过 cve 漏洞，搭过钓鱼 wifi 等（写到这，我想说一句，web 方向根本不好学好伐，各种知识体系纷繁复杂，各种框架层出不穷，相比底层感觉知识爆炸多啊😱, 直到现在都感觉也没有感觉哪个东西特别熟悉）</li>\n<li>咳咳。。。cut，每天时间有限，回忆完毕，进入正题：\n<ol>\n<li>对于技术的热爱。这个还是自己在宿舍思考的时候总结的，自己好多东西撒网太广，各式各样知识点太细太杂了，经常像熊瞎子掰苞米一样，这段时间搞这个熟点了，过了一段时间就又生疏了。这样子刚开始觉得没问题，忘了就再在网络搜再找就好了，温习一次就好了，但这样日积月累，花费的时间代价是巨大的，随着年龄的增长，越来越得不偿失，不如像好多大佬那样，整理自己的知识体系，有句话说得好，好记性不如烂笔头，更何况咱还没有大佬们那些好记性，干脆就记下来以自己的方式走就好了。</li>\n<li>合抱之木，生于毫末；九层之台，起于垒土；千里之行，始于足下。这个社会发展很快，很浮躁，每个人都急于要成绩，但有些事情我认为必须要降速，尤其是打基础阶段，好多东西是需要沉淀的，我们总是看到别人做的东西多么好多么绚丽，却忽视人家背后的积累，这是短视的，再复杂的东西也是靠着基础的语法语句一步步搭起来的，所以，元知识是非常重要的。</li>\n<li>简洁唯美。目前更想要的是将自己学的知识做一个记录整理并和大家分享积累，类似一个公开笔记一样，Github Pages 早有耳闻，但直到有需求才开始细了解，就像一条线一样，Github Pages---&gt;hexo---&gt; 霜月大佬主题 ---&gt; 准备入坑</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"0x03-总结\"><a class=\"anchor\" href=\"#0x03-总结\">#</a> 0x03 总结</h1>\n<ul>\n<li>总体来说就是这样吧，整理知识点，记录，和大家分享，和大家一起提升。<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL3poLWNuLw==\">hexo</span> 的东西和霜月大佬的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaG9rYS5sb3N0eXUubWUv\"> shoka 主题</span>还在熟悉中，好多东西一点点探索吧（😏新东西学起来总是有点激动呢😏）</li>\n</ul>\n<h1 id=\"0x04-目前站点问题\"><a class=\"anchor\" href=\"#0x04-目前站点问题\">#</a> 0x04 目前站点问题</h1>\n<ol>\n<li>评论系统未调</li>\n<li>搜索功能未调（目前刚开始，基本用不到，先放放😌）</li>\n<li>图床使用霜月大佬的链接（请不要喷我，我真的是太爱大佬收集整理的这些照片了，更何况自己找图床又不稳定，不如就用大佬的吧，哪天大佬的要是挂了再考虑自己整理一份吧，哈哈哈哈哈）</li>\n<li>目前整体文字性东西太少，远远不够和各位大佬做友链的级别，今后开始努力书写吧，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQjklOEMlRTYlOEIlODkvMTAyMjk0MTg/ZnI9YWxhZGRpbg==\">乌拉</span>～～～～～</li>\n<li>各项配置有待熟悉，摸索中。。。</li>\n</ol>\n",
            "tags": []
        }
    ]
}